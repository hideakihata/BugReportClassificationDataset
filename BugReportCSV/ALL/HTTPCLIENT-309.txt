 RFE Allow streaming of POST methods via chunked transfer encoding.
This is an RFE with a possible implementation attached. The implementation does not modify any existing code. We re using HTTP POST to send a large amount of data with an unknown size. We don t want to buffer the entire request so we implemented a streaming POST method. The implementation has 3 classes StreamedPostMethod BufferedChunkedOutputStream and OutputStreamWriter. The bulk of the code is in the BufferedChunkedOutputStream which may be a good target for replacing ChunkedOutputStream from the main distribution. BufferedChunkedOutputStream has the following charactersitics 1 It has an internal 2K buffer. Without the buffer chunk sizes would be too small in many cases e.g. ObjectOutputStream likes to call write byte with 4 byte long arguments . 2K was chosen to minimize the chunk overhead to less than 1 . 2 If the entire entity body fits within the 2K buffer it does not use chunking. This implies that the headers are only sent out when the first chunk or the entire body has to be written but no sooner. 3 The chunk size is not limited to 2K if write byte is called with a large argument the internal buffer and the new request are sent out as a single chunk. 4 Because of 2 it s tightly coupled to StreamedPostMethod.reallyWriteHeaders. 5 StreamedPostMethod calls BufferedChunkedOutputStream.finish to write the last buffer and ending chunk. Because of 4 and 5 we didn t want to touch ChunkedOutputStream. Interestingly EntityEnclosingMethod is already tightly coupled to ChunkedOutputStream because it has to call writeClosingChunk. There is probably some room for refactoring here. The package is just a suggestion feel free to move the files as appropirate. This code was written against 2.0rc2. We re hoping it will get included in time for the 2.1 release. To use the code you must implement OutputStreamWriter and pass it to StreamedPostMethod s constructor. Execute the method as usual. Caveats StreamedPostMethod does not implement Expect continue logic. We had no way to test this. It is also strictly for POST. In general the same methodology is applicable to PUT etc. It should be fairly simple to generalize. Legal Goldman Sachs Co. is making this code available under the Apache License.Created an attachment id 9912 possible implementation IMHO any entity enclosing method including POST already is capable of sending chunked transfer encoded requests. This can be enabled by calling EntityEnclosingMethod setRequestContentLength CONTENT LENGTH CHUNKED The feature is documented on the above mentioned method. But I like the optimization with your 2K buffer OdiThe point isn t just chunking. The real point is streaming . of course you can t have streaming without chunking . We send 100 s of MB of data. We simply can t afford to buffer everything upfront. Even if we could afford the memory in terms of raw performance a full buffered solution is about half the speed of a streaming solution because generating 10MB of data is a CPU intensive task. While the buffer is being created the network and tbe other side are totally idle. With streaming the client CPU encoding the server CPU decoding and the network all work simultaneously. The above solution was inspired by a thread in the mailing list http nagoya.apache.org eyebrowse ReadMsg listName commons-httpclient-dev jakarta.apache.org msgId 712986 It just so happens that the solution for streaming is pretty easy but not very useful without a good chunking implementation. Thanks MohMoh excuse me if I am wrong but the when using chunked transfer encoding with the current implementation the request is not buffered. So I still don t understand why you have a problem with the current behaviour of HttpClient. Please explain that. OdiThe problem is I need an OutputStream and HttpClient doesn t provide one. HttpUrlConnection does for example . Simply put I m serializing a large object graph and I m using ObjectOutputStream. There are 3 solutions as pointed out in the mailing list thread 1 Buffer everything. As explained above this is not a viable solution. 2 Use a PipedInputStream. That requires 2 threads for each send and frankly is not all that intuitive. 3 Provide access to the OutputStream this is the implementation we went with. Sorry if I wasn t clear. Thanks Moh Mohammad I have to say I find the solution you have presented far from being elegant. I really do not see why BufferedChunkedOutputStream class must be tightly coupled with HttpConnection HttpState. I personally find this a bit too much of a price to pay for not using chunk-encoding when the entire entity body fits within the 2K buffer. Is there anything I have missed as well OlegThe optimization for small buffers is just that an optimization. Chunking can be quite wasteful for small payloads both in terms of total transfered bytes and the logic to encode decode the chunk. As for the coupling to HttpConnection and HttpState I was just trying to be consistent with the current api. Practically all write methods in HttpMethodBase take HttpConnection and HttpState as parameters. That s not strictly necessary. In this particular case we could store those values in StreamedPostMethod and then BufferedChunkedOutputStream wouldn t ever get to see those. I think the real architectural issue here may be that HttpClient assumes all headers must be available before at least some processing is performed on the body. That assumption is not true in this case. There are other cases where that assumption makes using HttpClient difficult. For example consider a case where you conditionally compress the payload or not based on size. The content type can t be set until you ve decided to go one way or another and that will depend on processing the body. I tried to point out the coupling in the initial comment because I agree with you it is not elegant. I m not sure there is an elegant solution here. Honestly I dislike the reverse coupling StreamedPostMethod knowing about BufferedChunkedOutputStream even more. In good servlet implementations e.g. Tomcat 5.x Weblogic the stream layer is totally transparent. What a servlet does is not all that different than what HttpClient needs to do. Maybe the Tomcat architecture would be a good starting point for the 3.0 or at least something to keep in mind. BTW going back to the optimization some servlet containers do the same. Weblogic does. Tomcat does not. Thanks Moh The optimization for small buffers is just that an optimization. Chunking can be quite wasteful for small payloads both in terms of total transfered bytes and the logic to encode decode the chunk. Right but not in this particular case when all the available content 2K is sent as one chunk. One does incur an overhead of two headers for a payload chunk and a closing chunk but IMHO such overhead is negligible. I think the real architectural issue here may be that HttpClient assumes all headers must be available before at least some processing is performed on the body. The current architecture of HttpClient is simply broken. Period. It is in a dire need of a complete overhaul. But we do try to make things better not worse until we finally get a change to fix the HttpClient fundamentals. The attempt to implement deferred header writing on top of the existing architecture does not seem to make things better at least IMHO OlegMohammad My previous comment was not intended to discourage you and was not meant to make you think that your contribution was not welcome. Quite the opposite is the case. We certainly want to have the existing ChunkedOutputStream class replaced with your code. If just felt that output optimization based on the existing deficient architecture was not worth the trouble. This problem can be revisited in the course of 4.0 api overhaul. For the 3.0 release I would rather prefer a less intrusive approach. Would you be willing to continue working on this patch Oleghah It takes more than words to discourage me - I ve actually been a little busy but kept this in the back of my mind. The way I see it there are 3 ways to proceed in order of difficulty reverse order of goodness 1 Forget about refactoring the BufferedChunkedOutputStream and make it an inner class of StreamedPostMethod. This is actually how I wrote the code originally. 2 Take out the first chunk optimization. This makes BufferedChunkedOutputStream a simple replacement for the current implementation. See below. 3 Teach HttpMethodBase how to deal with delaying headers. This may not be too bad in time for 2.1 are we calling that 3.0 now . I haven t had time to take a close look. The reason I m hesitant about 2 is that HttpClient is used by a wide range of people most of whom don t care about large POST payloads. The nice thing about first chunk optimization is that it transparently uses a more widely available Content-Length header. There are alot of broken proxies load balancers firewalls webservers out there. It would be nice for a general purpose library to use the more common form when it can. There is nothing preventing people from doing their own buffering this is just a convenience. FYI for my purposes option 2 will be just fine. Thanks MohMohammad can we settle for option 2 for the 3.0 former 2.1 release The first chunk optimization will be revisited in the course of 4.0 massive API redesign. OlegArchitectural discussion aside I tried out Moh s classes and found them very useful. I have existing classes that are designed to read from an input stream and write to an output stream and Moh s code made it simpler to hook that into httpclient. So basically for my purposes the following inputstream - mycode - httpclient as an outputstream is better than inputstream - mycode - outputstream - inputstream - httpclient Bruce.This patch made life much easier for streaming requests. I am using JDOM to output xml and tried to use Piped Streams without much success to stream requests. This patch made it much easier to output JDOM to a stream using HttpClientCreated an attachment id 10684 A different take The attached patch is another take on this solution. It is an attempt to combine this request along with Odi s suggestion in http nagoya.apache.org eyebrowse BrowseList listName commons-httpclient- dev jakarta.apache.org by thread from 654699 . This patch is mostly just a proof of concept and still needs quite a bit of work. There are a few areas that I am a little unhappy with. In particular  - EntityEnclosingMethod.getRequestBody and getRequestBodyAsString are not so nice.  - Now that content length is moved to the RequestEntity the various content length methods on EntityEnclosingMethod are a little questionable. Please let me know what you think. MikeMike s patch looks good to me. I ve attached a direct replacement for ChunkedOutputStream that buffers writes to avoid tiny chunks.Created an attachment id 10705 Buffered ChunkedOutputStream To use the buffered ChunkedOutputStream one change is required In EntityEnclodingMethod the code          if outstream instanceof ChunkedOutputStream               ChunkedOutputStream outstream .writeClosingChunk           has to be changed to          if outstream instanceof ChunkedOutputStream               ChunkedOutputStream outstream .finish           finish flushes the cache as well writes the final chunk. Thanks Moh Mohammad The patch looks good to me. However I d like to see a few more things done before the new implementation of the ChunkedOutputStream class can be committed. Remove references to deprecated HttpConstants methods. Use corresponding methods of the EncodingUtil class instead Provide at least rudimentary Javadocs. Parameterizable buffer size. Simple ChunkedOutputStream ChunkedOutputStream OutputStream int constructor would do fine A SimpleHttpServer based test case would be just great. You may use TestBadContentLength test unit as a reference implementation Use unified diff output format diff -u against CVS HEAD to produce the patch if possible If you are constrained in time I can take over from here. However I really would like you to see this patch to its logical conclusion Cheers OlegCreated an attachment id 10706 patch that includes Oleg s suggestions without the test case Mohammad Cool. But test cases still need to be provided as the ChunkedOutputStream class has virtually no test case coverage at all. It s not fun but it needs to be done. Again I can take it from here but if you contibuted a few test cases it would be very welcome. OlegHere is my 2 cts. I don t see why buffering needs to be coupled with the chunking logic. I think the same effect can be achieved by just wrapping the stream into a BufferedOutputStream no That ugly instanceof problem should be solved anyway . Two more things about the patch   please follow the original coding conventions braces and linebreaks   license terms must be accoring to the ASF - no third-party copyrights please use author tag we will mention Goldman Sachs in the Obtained-From field in the CVS comment when committing.   Ortwin The whole point of buffering is to avoid tiny chunks. Here is Sun s code from BufferedOutputStream     public synchronized void write byte b int off int len throws IOException if len buf.length If the request length exceeds the size of the output buffer      flush the output buffer and then write the data directly.      In this way buffered streams will cascade harmlessly. flushBuffer out.write b off len return if len buf.length - count flushBuffer System.arraycopy b off buf count len count len      Here are two conditions under which the patch behaves better let s assume 2048 byte buffer 1 Buffer has 5 bytes in it and a request to write 2048 bytes is received. BufferedOutputStream would cause 2 chunks to be written one of length 5 one 2048. The new ChunkedOutputStream would write a single chunk of size 2053. 2 Buffer has 5 bytes in it and a request to write 2047 bytes is received. BufferedOutputStream would cause a 5 byte chunk and buffer the rest for later which incurs an unnecessary System.arrayCopy . The new ChunkedOutputStream writes a 2052 byte chunk. Essentially what you get from BufferedOutputStream is a crapshoot. It s anywhere from 1 to buf.length or the size of the passed in request . A chunk of length 1 has 500 overhead. ChunkedOutputStream guarantees a minimum chunk size except for the last chunk . I ll fix up the copyright and resubmit. Thanks MohOkay now I see. Thanks for explaining this to me. You get my GO - Created an attachment id 10728 patch with correct style and copyright I believe the patch is almost ready. I ll provide a few simple test cases if nobody steps in and commit the patch in a day or two provided nobody objects. OlegWorks for me... Any comments on my changes to EntityEnclosingMethod MikeCreated an attachment id 10750 Latest Mohammad s patch test cases I have added a few test cases to the latest Mohammad s patch. If nobody objects I ll commit the patch in 24 hours. OlegMike I like the patch but can t help thinking that 2.0 API compatibility code defeats the whole beauty of it. I would rather see all the setRequestBody getRequestBody methods removed for good. After all we are going to ship a major version upgrade. OlegHi Oleg Keeping the API compatibility definitely makes things a little nastier here. The getRequestBody methods could possibly be removed. I don t believe they serve much of a purpose in general use. The setReqestBody and content length methods should just be deprecated I think. They are too widely used to be removed I think. They are also much less of a hack. How does that sound MikeHi Mike That sounds like a good plan. Let us get rid of useless getRequestBody methods and deprecate setRequestBody ones OlegMohammad s ChunkedOutputStream patch committed. Many thanks Mohammad for this contribution. OlegCreated an attachment id 11329 RequestEntity patch 2 Attached is above is an updated version of the RequestEntity patch. This one adds some comments removes the getRequestBody methods and deprecates the setContentLength methods. I am also tempted to move the Content-Type into the RequestEntity but have not decided for sure yet. Any comments suggestions MikeLooks great. 1 to apply. 1 from me. Making Content-Type a propery of the RequestEntity does seem reasonable too. OlegPatch applied. I m going to create a new RFE to cover moving the Content-Type. I have also removed the deprecated tag on setRequestBody String until the content type is moved. MikeCreated an attachment id 11368 Followup patch Folks I would like to have a few more constructors added to the ByteArrayRequestEntity InputStreamRequestEntity classes if nobody objects. I would also like to suggest that all concrete classes implementing RequestEntity made immutable. That is no more parameterless constructors no more setContent methods. The patch also adds StringRequestEntity class in addition to ByteArrayRequestEntity InputStreamRequestEntity Let me know what you think OlegHi Oleg A few comments - The new constructors are good but there is a problem with the ByteArrayRequestEntity . It will always result in an exception since it s calling this null .  - I have no problem making these classes immutable but I m not sure it s really required. What s the motivation  - I think we should wait until we move the Content-Type to add a StringRequestEntity. That way we can handle the charset problems all at once. I had originally created a StringRequestEntity but left it out for this reason.  - Could StringRequestEntity.writeRequest be simplified to      Writer writer null      if this.charset null          writer new OutputStreamWriter out this.charset       else          writer new OutputStreamWriter out            writer.write content Mike The new constructors are good but there is a problem with the ByteArrayRequestEntity . It will always result in an exception since it s calling this null . My initial intention was to do away with ByteArrayRequestEntity but than I thought I should discuss it with you first. - I have no problem making these classes immutable but I m not sure it s really required. What s the motivation Primarily in order to avoid throwing IllegalStateException. If parameterless constructors and setContent may leave entity request objects in a inconsistent state why should they exist in the first place - I think we should wait until we move the Content-Type to add a StringRequestEntity. That way we can handle the charset problems all at once. I had originally created a StringRequestEntity but left it out for this reason. I have concerns that some JDKs may end up converting the entire String to an array of bytes prior to writing into the underlying output stream which would result in unnecessary waste of memory. I may be a little too pessimistic here though Mike just take over those bits that you think make sense and incorporate them into your coming patch.Oleg Okay with me to make them immutable. This is generally a good design choice. Ortwin GlÃ ck My initial intention was to do away with ByteArrayRequestEntity but than I thought I should discuss it with you first. What would we use as a replacement The InputStreamReqestEntity Primarily in order to avoid throwing IllegalStateException. If parameterless constructors and setContent may leave entity request objects in a inconsistent state why should they exist in the first place I hear you. This goes along with the immutability. Fine with me. I have concerns that some JDKs may end up converting the entire String to an array of bytes prior to writing into the underlying output stream which would result in unnecessary waste of memory. I may be a little too pessimistic here though I think we should stay simple here until we run into a potential performance problem. Mike just take over those bits that you think make sense and incorporate them into your coming patch. Ok. Can do. Mike What would we use as a replacement The InputStreamReqestEntity Mike I apologize for not making myself clear enough. I did not mean the ByteArrayRequestEntity class itself but rather its parameterless constructor the one that causes an exception in my patch. Oleg
