CMS merge throttling is not aggressive enough
I hit this crab while working on the NRT benchmarker in luceneutil . CMS today forcefully idles any incoming threads when there are too many merges pending. This is the last line of defense that it has since it also juggles thread priorities and forcefully idles the biggest merges to try to reduce the outstanding merge count. But when it cannot keep up it has no choice but to stall those threads responsible for making new segments. However the logic is in the wrong place now Ð the stalling happens after pulling the next merge from IW. This is poor because it means if you have N indexing threads you allow max N outstanding merges. I have a simple fix which is to just move the stall logic to before we pull the next merge from IW. Mike now that you wait before you poll IW.getNextMerge isn t there a risk CMS pulled from IW all of its merges say 1 maxMergeCount but there are no more merges So now the code will wait until one of the merges completes before the user gets back control since it s CMS.merge IW that waits So now the code will wait until one of the merges completes before the user gets back control since it s CMS.merge IW that waits Right that s exactly what we want to happen I think Ie that thread is in CMS because it is a thread responsible somehow for adding new segments to the index ie it called getReader or commit or expungeDeletes etc. and we are in a situation where too many merge threads are running so we forcefully stall the incoming thread. This is the last line of defense that CMS has to prevent over-production of segments vs rate of consumption from merging . So if the user allows for N max-merges in CMS and MP returns N merges to be executed then this is fine. If however MP returns N 1 merges then CMS will register N 1 merges and then stall I m asking because the while checks for mergeThreadCount 1 maxMergeCount. Before your changes at most maxMergeCount merges could be registered while now the code allows for maxMergeCount 1 I m confused. And my question I think is stil valid - what if CMS waits for nothing - meaning after wait finishes IW.getNextMerge returns null The user thread will be blocked until then even though no more merges are pending Perhaps I m just confused though ... If however MP returns N 1 merges then CMS will register N 1 merges and then stall Right now I allow N 1 merges to be running and then all incoming threads will stall. We could change that remove the 1 but I didn t like that because then we stall app threads when exactly the max allowed number of merges are running. Before your changes at most maxMergeCount merges could be registered No before my change maxMergeCount plus the number of app threads you send into IW could be registered. This was the bug Ð that our last line of defense was vulnerable to how many app threads you send in . And my question I think is stil valid - what if CMS waits for nothing - meaning after wait finishes IW.getNextMerge returns null The user thread will be blocked until then even though no more merges are pending That s exactly the case I d expect to happen. It s not for nothing Ð it s very much to stall the thread that s responsible for causing new segments to be added. The fact that after the stall there are likely no new merges to do is fine... the app thread runs free and then produces more segments again. Really if we could somehow cutover to a blocking queue... where MergePolicy is the producer and MergeScheduler consumes that d be cleaner. Bulk close for 3.1
