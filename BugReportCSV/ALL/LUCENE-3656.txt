IndexReader s add removeCloseListener should not use ConcurrentHashMap just a synchronized set
The use-case for ConcurrentHashMap is when many threads are reading and less writing to the structure. Here this is just funny The only reader is close . Here you can just use a synchronized HashSet. The complexity of CHM is making this just a joke 1 1 Simple patch. I had to add some additional synchronization in the notifier as the iterators are not thread-safe. Collections.synchronized returns a set thats synced on itsself so you can for more complex changes like iteration sync on the result the Set itsself see for complete explanation http docs.oracle.com javase 1.5.0 docs api java util Collections.html synchronizedSet java.util.Set One more thing because Robert reminded me I changed to use a LinkedHashSet instead simple HashSet because the caller adding listeners would expect that they are called in order on close. Adding them to a HashSet makes they executed in arbitrary order and thats not what a user expects. The Linked does not cost us much as the number of listeners should be low Uwe this seems a pretty good usecase for CopyOnWriteArraySet. No sync but thread-safe and reasonably cheap. this seems a pretty good usecase for CopyOnWriteArraySet. 1 good call. I agree that for small ordered sets like Handlers Listender see example from Javadocs this is a good idea but its still the wrong set for this use case The listeners on close are registered by code that may unlikely come from different threads e.g. FieldCacheImpl registers an event to purge the caches on IndexReader close or maybe in future Solr registers a handler - this is generally done on setup of IndexReader . In general synchronization would not really be required at all but as also different threads may register listeners there should be some basic synchronization. If you would use CopyOnWriteArraySet registering removing new listeners gets slow as it has to copy the array each time so registering event handlers will not block but just be slow. On the other hand we have very fast access just for exactly one single iteration on thi set when the listeners are triggered on closing the reader . We get this for free without sync but who cares IndexReader.close is the last operation on an IR where you have no concurrency anymore. I think we should stay with a simply synchronized LinkedHashSet which is cheap as concurrency is no issue at all not many threads will ever register an event the whole synchronization is just to guard the set for concurrent modifications e.g. if two threads create a new FieldCache entry at same time . The addition cost for sync on IR.close is a no-op as explained above no concurrecy anymore . Any comments about my explanation to still use LHM otherwise I will commit this in the evening I think we should stay with a simply synchronized LinkedHashSet 1 1 its the right data structure here. Simple refactorings to make the code in IR and SCR SR similar. Will commit this now. Committed trunk revision 1221369 Merged 3.x revision 1221371
