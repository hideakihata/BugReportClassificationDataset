add support to caching module for RFC 5861 stale-on-error and stale-while-revalidate 
These are Cache-Control extensions that allow an origin server to specify some additional behavior for stale cache entries. Stale-on-error configurations allow a cache to continue serving stale content for a certain period of time if a revalidation fails and stale-while-revalidate similarly allows revalidation to occur asynchronously. Some reverse proxies such as Squid can be configured to understand these headers which means that some origin servers are probably sending them and that we can likewise take advantage of them. This patch adds support for stale-if-error - Cache-Control extension as defined in RFC 5861. Many thanks to my colleagues Matthew Hawthorne and Michajlo Matijkiw for their valuable inputs. This patch has been submitted with the permission of my employer. Thanks Mohammed AzeemThis patch adds the stale-while-revalidate cache control extension. This is accomplished with an ExecutorService that qualifying requests are handed off to for revalidtion. Multiple revalidations for a single URI will be collapsed into one request. The number of background threads to be made available for asynchronous revalidation the max number of concurrent revalidations can be set in the CacheConfig object. The default is 1 and a value of less than or equal to 0 will tell the CachingHttpClient to ignore the stale-while-revalidate directive and handle all revalidations synchronously. If applying this patch and the stale-if-error patch produce messy conflicts when applied I can combine the two. This patch is contributed with the permission of my employer. Thanks Michajlo Mohammed can you rebuild the patch against the latest trunk It doesn t quite apply right at the moment. I did however review the patch and it looks generally good. Mishu let s keep the patches separate for now and apply them one at a time. Probably the stale-while-revalidate patch will need to be rebuilt but it s probably easier to do that after the stale-if-error patch has been applied. Rebuilt the patch against the latest trunk. Thanks Mohammed Mohammed patch checked in. I moved the acceptance tests from TestProtocolRecommendations to a new test class called TestRFC5861Compliance since I think we want to keep TestProtocolRecommendations to those things specified in RFC2616. Mishu go for the stale-while-revalidate patch. Here is the patch bought up to date with trunk. I also fixed a small typo i came across in CacheKeyValidator. This patch is submitted with the permission of my employer. - Mishu Mishu thanks Patch committed. I changed the default setting of background revalidation workers to 0 disabling the feature by default but only temporarily. The default fixedThreadPool being used right now has a potentially unbounded queue length which I think isn t safe for a default setting. I m planning to add CacheConfig settings for the max idle worker lifetime and the max queue length with sensible defaults then re-enable the feature by default with conservative settings. I think I found a bug in the current implementation I think stale-while-revalidate probably needs to be subject to the same rules as those we apply when a revalidation fails due to an IOException. Namely stale-while-revalidate probably needs to yield to must-revalidate it is possible although strange for both directives to appear and proxy-revalidate and should probably also not asynchronously validate if the request has an explicit freshness requirement max-stale for example . Also I am finding that the main execute method in CachingHttpClient is in serious need of refactoring it is really getting far too long so I m going to start by cleaning up there. Upon re-reading the section of RFC2616 about cache control extensions http www.w3.org Protocols rfc2616 rfc2616-sec14.html sec14.9.6 It does seem like the MAY of stale-if-error and stale-while-revalidate should yield to the MUSTs of must-revalidate and proxy-revalidate and the SHOULD NOT of returning a stale response if the client s request includes explicit freshness contraints. I ve also reached out to Mark Nottingham the author of RFC5861 to validate this understanding. In the meantime I ll update the behavior here.Mark Nottingham confirmed my reading of things so I ll continue as planned in flight right now .
